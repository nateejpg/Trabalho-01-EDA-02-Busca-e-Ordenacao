# Trabalho 1 - Estrutura de Dados 2
Repositório da dupla 31, Natham Abreu e João Pedro, para os projetos da disciplina de EDA 2. 

## Temas
Os temas de projeto são:  
 
 - Ord_quad - Algoritmos de ordenação O(n²)  
 - Ord_nlogn - Algoritmos de ordenação O(n*log(n))  
 
Os algoritmos de ordenação específicos que foram implementados nesse projeto foram os seguintes (sendo que para algoritmo acrescentamos também sua complexidade para o médio caso na frente de seu nome): 

 - Bubble Sort (O(n²))
 - Selection Sort (O(n²))
 - Insertion Sort (O(n))
 - Quick Sort (O(n log n))
 - Merge Sort (O(n log n))
 - Heap Sort (O(n log n)) 
 - Bucket Sort (O(n+k)) 
 - Shell Sort (O(n)) 
 - Counting Sort (O(n+k))
  


  
 
 
## Alunos  
| Matrícula | Nome |  
|-----------------------|-----------------------------------|  
| 211031074 | João Pedro da Silva Rodrigues |  
| 221022696 | Nathan Abreu |  

## Descrição do projeto
Este projeto, desenvolvido para a disciplina de Estrutura de Dados 2 ministrada pelo professor Maurício, tem como objetivo a implementação e análise de diferentes algoritmos de ordenação. O projeto desenvolvido foi uma aplicação web que permite ao usuário gerar um array aleatório ou inserir seu próprios números que ele deseja ordenar, e depois o usuário escolhe quais dos algoritmos de ordenação ele deseja aplicar no seu array, e por fim a aplicação gera uma animação para mostrar o passo a passo da ordenação para o usuário e por fim exibe retorna para o usuário o array ordenado. Portanto este projeto contém as implementações dos algoritmos estudados em sala, bem como testes e comparações de desempenho entre eles.

## Guia de instalação
Aqui devem estar descritas as dependências do projeto (versões de linguagens e ferramentas) e as instruções necessárias para executar o projeto. 
### Dependências do projeto
### Como executar o projeto
1. Clone o repositório:
```
   git clone [https://github.com/nateejpg/Trabalho-01-EDA-02-Busca-e-Ordenacao.git](https://github.com/nateejpg/Trabalho-01-EDA-02-Busca-e-Ordenacao.git)
```
2. Execute o arquivo index.html da forma como você preferir. 
   
## Capturas de tela
Neste tópico você poderá observar as capturas de tela do funcionamento de cada algoritmo de ordenação do ponto de vista do usuário.  
 
### Bubble Sort 

<img src="./prints/bubbleSort/Captura de tela de 2025-09-06 16-20-32.png" alt="Minha imagem" width="300"/>
<img src="./prints/bubbleSort/Captura de tela de 2025-09-06 16-20-59.png" alt="Minha imagem" width="300"/>
<img src="./prints/bubbleSort/Captura de tela de 2025-09-06 16-21-12.png" alt="Minha imagem" width="300"/>

### Heap Sort 

<img src="./prints/heapSort/Captura de tela de 2025-09-06 16-57-57.png" alt="Minha imagem" width="300"/>
<img src="./prints/heapSort/Captura de tela de 2025-09-06 16-58-12.png" alt="Minha imagem" width="300"/>
<img src="./prints/heapSort/Captura de tela de 2025-09-06 16-58-20.png" alt="Minha imagem" width="300"/>
<img src="./prints/heapSort/Captura de tela de 2025-09-06 17-02-49.png" alt="Minha imagem" width="300"/>

### Insertion Sort 

<img src="./prints/insertionSort/Captura de tela de 2025-09-06 16-48-19.png" alt="Minha imagem" width="300"/>
<img src="./prints/insertionSort/Captura de tela de 2025-09-06 16-48-28.png" alt="Minha imagem" width="300"/>
<img src="./prints/insertionSort/Captura de tela de 2025-09-06 16-48-35.png" alt="Minha imagem" width="300"/>
<img src="./prints/insertionSort/Captura de tela de 2025-09-06 16-48-43.png" alt="Minha imagem" width="300"/>

### Merge Sort 

<img src="./prints/mergeSort/Captura de tela de 2025-09-06 16-55-34.png" alt="Minha imagem" width="300"/>
<img src="./prints/mergeSort/Captura de tela de 2025-09-06 16-55-41.png" alt="Minha imagem" width="300"/>
<img src="./prints/mergeSort/Captura de tela de 2025-09-06 16-55-50.png" alt="Minha imagem" width="300"/>

### Quick Sort 

<img src="./prints/quickSort/Captura de tela de 2025-09-06 16-52-52.png" alt="Minha imagem" width="300"/>
<img src="./prints/quickSort/Captura de tela de 2025-09-06 16-53-00.png" alt="Minha imagem" width="300"/>
<img src="./prints/quickSort/Captura de tela de 2025-09-06 16-53-10.png" alt="Minha imagem" width="300"/>

### Selection Sort 

<img src="./prints/selectionSort/Captura de tela de 2025-09-06 16-43-59.png" alt="Minha imagem" width="300"/>
<img src="./prints/selectionSort/Captura de tela de 2025-09-06 16-44-08.png" alt="Minha imagem" width="300"/>
<img src="./prints/selectionSort/Captura de tela de 2025-09-06 16-44-29.png" alt="Minha imagem" width="300"/>

### Bucket Sort 

<img src="./prints/bucketSort/Captura de tela de 2025-09-07 02-26-54.png" alt="Minha imagem" width="300"/>
<img src="./prints/bucketSort/Captura de tela de 2025-09-07 02-27-00.png" alt="Minha imagem" width="300"/>
<img src="./prints/bucketSort/Captura de tela de 2025-09-07 02-27-07.png" alt="Minha imagem" width="300"/>

### Shell Sort 

<img src="./prints/shellSort/Captura de tela de 2025-09-07 03-00-34.png" alt="Minha imagem" width="300"/>
<img src="./prints/shellSort/Captura de tela de 2025-09-07 03-01-05.png" alt="Minha imagem" width="300"/>
<img src="./prints/shellSort/Captura de tela de 2025-09-07 03-01-13.png" alt="Minha imagem" width="300"/>
<img src="./prints/shellSort/Captura de tela de 2025-09-07 03-01-25.png" alt="Minha imagem" width="300"/>

### Counting Sort 

<img src="./prints/countingSort/Captura de tela de 2025-09-07 03-27-09.png" alt="Minha imagem" width="300"/>
<img src="./prints/countingSort/Captura de tela de 2025-09-07 03-27-29.png" alt="Minha imagem" width="300"/>
<img src="./prints/countingSort/Captura de tela de 2025-09-07 03-29-21.png" alt="Minha imagem" width="300"/>
<img src="./prints/countingSort/Captura de tela de 2025-09-07 03-29-29.png" alt="Minha imagem" width="300"/>






## Conclusões

Cada um dos algoritmos de ordenação apresentados nesse trabalho tem seus prós e contras. Agora eu vou citar as utilidades e vulnerabilidades de cada um dos algoritmos usados nessa aplicação: 

### Bubble Sort 

- Vantagens: Para começar o bubble sort é um algoritmo estável, ou seja, ele mantém a ordem relativa elementos iguais. E se os dados já estiverem quase ordenados, o bubble sort otimizado com a flag de troca pode terminar cedo, aproximando-se de O(n). 

- Desvantagens: O bubble sort é pouco eficiente, com complexidade O(n²) para o pior caso e o médio caso, o que o torna extremamente lento para listas grandes comparado a outros algoritmos. Outra desvantagem é que mesmo que a lista já esteja quase ordenada, sem a otimização da flag, ele ainda percorre toda a lista várias vezes. 
  
### Heap Sort 

- Vantagens: O heap sort possui complexidade garantida, ele sempre executa em O(n log n) no pior, médio e melhor caso, diferente do quick sort que pode cair para O(n²) em certos casos. Ele também é mais econômico em memória que o merge sort, e a sua estrutura garante eficiência mesmo em listas muito grandes. 
  
- Desvantagens: Para começar o heap sort não é estável. Ele também realiza muitas trocas em posições distantes do array, isso causa menos eficiência no uso da memória cache do processador, deixando-o mais lento em arquiteturas modernas. 

### Insertion Sort 

- Vantagens: O insertion Sort é estável e para entradas de tamanho reduzido pode ser melhor que algoritmos complexos devido ao baixo overhead. Além disso se os dados já estiverem quase ordenados ele pode se aproximar da complexidade O(n). 
  
- Desvantagens: Ele possui alta complexidade em listas grandes e mesmo no caso médio ele continua sendo O(n²). Além disso, ao inserir um elemento na posição correta, ele pode deslocar vários outros elementos, o que consome tempo. 

### Merge Sort 

- Vantagens: O merge sort é um dos algoritmos mais usados na teoria e na prática. Ele possui complexidade garantida, sempre executa em O(n log n), independentes da distribuição dos dados. Estável, ou seja sempre mantém a ordem relativa entre elementos iguais. Ele pode ser implementado em um merge sort externo, o que permite a ele ordenar arquivos muito grandes que não cabem na memória RAM. Ele também possui um estrutura recursiva clara e elegante, que facilita o racícinio e depuração. 
  
- Desvantagens: Ele precisa de O(n) espaço adicional para armazenar arrays auxiliares durante o processo de mesclagem, isso o torna menos adequado para ambientes com memória limitada. O overhead da recursão e das cópias de arrays faz com que seja mais lento que algoritmos simples como insertion sort em entradas pequenas. 
  
### Quick Sort 

- Vantagens: Apesar do pior caso ser O(n²), com boas escolhas de pivô o  desempenho médio é O(n log n) e geralmente é mais rápido que o merge sort e o heap sort. Ele também precisa de pouca memória extra e trabalha diretamente dentro do array, com acessos locais, aproveitando melhor a memória cache da cpu do que o merge sort. 
  
- Desvantagens: Se o pivô for mal escolhido o desempenho degrada drasticamente. Não é estável. Em implementações recursivas, pode haver estouro de pilha em listas muito grandes se não houver otimização. Precisa de estratégias como mediana de três, pivô aleatório ou híbridos para manter o desempenho bom o em diferentes distribuições de dados. 

### Selection Sort 

- Vantagens: Ele é simples para implementar, efetua um número mínimo de trocas e faz ordenação in-place então ele não precisa de memória extra significativa. 

- Desvantagens: É pouco eficiente em grandes listas por ser quadrático em todos os casos. Não é estável. Não aproveita listas parcialmente ordenadas e faz um número excessivo de comparações embora efetue poucas trocas. 
  
### Bucket Sort 

- Vantagens: Ele pode ser muito rápido em casos ideais, com dados uniformemente distribuídos, nos quais sua compelexidade chega próximo de O(n). Ele é estável e também pode usar qualquer algoritmo de ordenação dentro dos buckets, permitindo otimizações específicas. 

- Desvantagens: Ele não é in-place, o que significa que ele precisa de espaço O(n+k) para os buckets. Se muitos elementos caírem no mesmo bucket o algoritmo degenera podendo chegar a O(n²). Exige planejamento do número de buckets e escolha de um algoritmo interno de ordenação. 
  
### Shell Sort 

- Vantagens: Mais rápido que o insertion sort, pois movimenta elementos distantes reduzindo deslocamentos e comparações. Ele é in-place, o que significa que ele não precisa de memória extra significativa. Ele é flexível, pois pode usar diferentes formas de gap, permitindo otimizações. 
  
- Desvantagens: Não é estável. O desempenho ótimo depende da escolha da sequência de incrementos. Ele é mais complexo do que outros algoritmos, de modo que sua implementação exige mais cuidado. A complexidade exata depende da sequência de gaps, de modo que não existe uma fórmula universal. 

### Counting Sort 

- Vantagens: Ele é muito rápido para inteiros dentro de um intervalo limitado, pode atingir complexidade O(n+k), sendo extremamente eficiente quando k não é muito maior que n. É estável. Não usa comparações, ao invés disso baseia-se em contagem de ocorrências, não em comparações entre elementos. 

- Desvantagens: Depende demais do intervalo de valores, de modo que se os elementos forem grandes demais ou muito dispersos, o array de contagem pode consumir muita memória. não funciona para valores não inteiros. Não é in-place. 


